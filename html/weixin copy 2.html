<!DOCTYPE html>
<html lang="zh-CN">
<!--告诉浏览器该网站的语言-->

<head>
    <meta charset="utf-8">
    <!--万国码-->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 样式 -->
    <link rel="stylesheet/less" type="text/css" href="./less/style.less">

    <!-- 引入代码高亮的主题css -->
    <link rel="stylesheet" type="text/css" href="../lib/highlight/styles/atom-one-dark.min.css">

    <!-- 引入代码样式代码 -->
    <link rel="stylesheet" type="text/css" href="./css/highlight.css">

    <!-- 引入目录代码样式 -->
    <link rel="stylesheet" type="text/css" href="../lib/dist/tocbot.css">
    <title>微信小程序</title>
    <style>

    </style>

</head>

<body>





    <div class="aside">
        <div class="aside1 ">
            <ul>
                <li>
                    <h3>html框架</h3>
                </li>
                <li><a href="#" class="aside_a">1111</a></li>
                <li><a href="#" class="aside_a">1111</a></li>
            </ul>
            <span>目录</span>
            <ol class="js-toc"></ol>
        </div>
    </div>




    <div class="zhuTi js-toc-content">


        <p>数据渲染是指通过模板语法把 data 中的数据展示到页面当中，小程序有一套专门的模板语法来实现数据的渲染。</p>

        <h2>1.1 双向绑定</h2>

        <p>小程序中通过插值语法，即双大括号实现数据的绑定，我们来将上一小节定义的数据渲染到页面当中：</p>

        <pre><code>
// pages/index/index.js
// 调用 Page 函数
Page({
  data: {
    msg: &#39;大家好，这是我的第一个小程序！&#39;,
  },
  // 方法
  sayHi(name = &#39;小明&#39;) {
    console.log(&#39;你好&#39; + name)
  },
})
        </code></pre>

        <pre><code>
&lt;!-- pages/index/index.wxml --&gt;
&lt;view class=&quot;msg&quot;&gt;{{msg}}&lt;/view&gt;
&lt;!-- 重点注意，属性的绑定也是 {{}} --&gt;
&lt;input name=&quot;number&quot; value=&quot;{{msg}}&quot; /&gt;
        </code></pre>

        <p>上述代码就是小程序数据绑定的语法了，重点要注意对【属性的绑定】使用的仍然采用插值语法。</p>

        <blockquote>
            <p>小程序支持简易的数据双向绑定，语法如下所示：</p>
        </blockquote>

        <p>语法：<code>model:value=&quot;{{变量名}}&quot;</code></p>

        <pre><code>
&lt;input name=&quot;number&quot; model:value=&quot;{{msg}}&quot; /&gt;
        </code></pre>

        <p>大家要注意并不是所有的表单元素都支持数据双向绑定，其中 <code>input</code>、<code>textarea</code>、<code>slider</code> 组件可以支持。</p>

        <h2>扩展-属性绑定</h2>

        <blockquote>
            <p>对元素上的属性进行动态绑定</p>
        </blockquote>

        <p>语法：<code>属性名=&quot;{{data}}&quot;</code></p>

        <pre><code>
  data: {
    addClass: true,
    url:&#39;/pages/meng/index&#39;,
  }   
        </code></pre>

        <pre><code>
&lt;view class=&quot;{{addClass?&#39;className1&#39;:&#39;className2&#39;}}&quot;&gt;
	&lt;text&gt;动态class&lt;/text&gt;
  &lt;navigator url=&quot;{{url}}&quot;&gt;go&lt;/navigator&gt;
&lt;/view&gt;
        </code></pre>

        <h2>1.2 列表渲染</h2>

        <blockquote>
            <p>如果 data 中有一个数组类型的列表数据，我们要如何渲染出来呢？</p>
        </blockquote>

        <p>小程序提供了一个指令 <code>wx:for</code> 类似于 Vue 中的 <code>v-for</code>，通过一个小例子来学习：</p>

        <pre><code>
// pages/index/index.js
// 调用 Page 函数
Page({
  data: {
    msg: &#39;大家好，这是我的第一个小程序！&#39;,
    number: 1,
    students: [
      { id: 1, name: &#39;小明&#39;, age: 18, gender: &#39;男&#39; },
      { id: 2, name: &#39;小红&#39;, age: 17, gender: &#39;女&#39; },
      { id: 3, name: &#39;小刚&#39;, age: 19, gender: &#39;男&#39; },
      { id: 4, name: &#39;小丽&#39;, age: 18, gender: &#39;女&#39; },
      { id: 5, name: &#39;小米&#39;, age: 19, gender: &#39;女&#39; },
    ],
  },
  // 方法
  sayHi(name = &#39;小明&#39;) {
    console.log(&#39;你好&#39; + name)
  },
})
        </code></pre>

        <h3>1.2.1 基本的语法格式</h3>

        <p>语法：<code>wx:for=&quot;{{数据名称}}&quot;</code></p>

        <p>v-pre
            <code>wx:for</code> 的语法格式为 <code>wx:for=&quot;{{ 数据名称 }}&quot;</code> ，并且<strong>内置默认</strong>通过
            <code>index</code> 获取数组的<strong>索引值</strong>，<code>item</code> 访问<strong>数组的单元值</strong>，如下代码所示：
        </p>

        <pre><code>
&lt;!-- pages/index/index --&gt;
&lt;view class=&quot;students&quot;&gt;
  &lt;view class=&quot;item&quot;&gt;
    &lt;text&gt;序号&lt;/text&gt;
    &lt;text&gt;姓名&lt;/text&gt;
    &lt;text&gt;年龄&lt;/text&gt;
    &lt;text&gt;性别&lt;/text&gt;
  &lt;/view&gt;
  &lt;view class=&quot;item&quot; wx:for=&quot;{{students}}&quot;&gt;
    &lt;text&gt;{{index + 1}}&lt;/text&gt;
    &lt;text&gt;{{item.name}}&lt;/text&gt;
    &lt;text&gt;{{item.age}}&lt;/text&gt;
    &lt;text&gt;{{item.gender}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
        </code></pre>

        <p>上述代码中 <code>index</code> 读取的是数组的索引值，<code>item</code> 读取的是数组的单元。</p>

        <p>在使用 <code>wx:for</code> 时会收到一个警告，如下图：</p>

        <p><img alt="没有wx:key" src="./images/weixin/picture_2-9624429.jpg" /></p>

        <p>上述警告是由于在使用 <code>wx:for</code> 时没有指定 <code>wx:key</code> 属性，这个 <code>wx:key</code> 属性的作用于 Vue
            中一样的，但是语法稍有不同，大家一定要注意，如下所示：</p>

        <pre><code>
&lt;!-- pages/index/index --&gt;
&lt;view class=&quot;students&quot;&gt;
  &lt;view class=&quot;item&quot;&gt;
    &lt;text&gt;序号&lt;/text&gt;
    &lt;text&gt;姓名&lt;/text&gt;
    &lt;text&gt;年龄&lt;/text&gt;
    &lt;text&gt;性别&lt;/text&gt;
  &lt;/view&gt;
+ &lt;view class=&quot;item&quot; wx:for=&quot;{{students}}&quot; wx:key=&quot;name&quot;&gt;
    &lt;text&gt;{{index + 1}}&lt;/text&gt;
    &lt;text&gt;{{item.name}}&lt;/text&gt;
    &lt;text&gt;{{item.age}}&lt;/text&gt;
    &lt;text&gt;{{item.gender}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>

        <p>上述代码中 <code>wx:key</code> 属性的值要求必须具有唯一性，使用时分成两种情形：</p>

        <ul>
            <li>数组单元为简单类型数据时，使用 <code>*this</code> 指定为 <code>wx:key</code> 的值</li>
            <li>数组单元是对象类型时，只要写对象的属性名</li>
        </ul>

        <h3>1.2.2 自定义访问单元值和索引值</h3>

        <blockquote>
            <p>通过 <code>wx:for-index</code> 和 <code>wx:for-item</code> 来分别指定如何访问数组的索引值和单元值，如下代码所示：</p>
        </blockquote>

        <p>语法：<code>wx:for-index=&quot;索引名&quot;</code> <code>wx:for-item=&quot;单元名&quot;</code></p>

        <pre><code>
&lt;!-- pages/index/index --&gt;
&lt;view class=&quot;students&quot;&gt;
  &lt;view class=&quot;item&quot;&gt;
    &lt;text&gt;序号&lt;/text&gt;
    &lt;text&gt;姓名&lt;/text&gt;
    &lt;text&gt;年龄&lt;/text&gt;
    &lt;text&gt;性别&lt;/text&gt;
  &lt;/view&gt;
  &lt;view class=&quot;item&quot; wx:for=&quot;{{students}}&quot; wx:for-index=&quot;key&quot; wx:for-item=&quot;student&quot;&gt;
    &lt;text&gt;{{key + 1}}&lt;/text&gt;
    &lt;text&gt;{{student.name}}&lt;/text&gt;
    &lt;text&gt;{{student.age}}&lt;/text&gt;
    &lt;text&gt;{{student.gender}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>

        <p>上述代码中分别指定了 <code>key</code> 获取的是数组的索引值，<code>student</code> 获取的是数组的单元值。</p>

        <h2>1.3 条件渲染</h2>

        <h3>1.3.1 wx:if</h3>

        <blockquote>
            <p>在对数据进行渲染时经常需要根据条件来处理，如后台暂无数据提示，可以使用 <code>wx:if</code> 来实现，我们来看具体的用法：</p>
        </blockquote>

        <p>语法：<code>wx:if=&quot;{{布尔值}}&quot;</code></p>

        <pre><code>
&lt;!-- pages/index/index.wxml --&gt;
&lt;!-- 省略前面小节的代码 --&gt;
+ &lt;view class=&quot;students&quot; wx:if=&quot;{{students.length&gt;0}}&quot;&gt;
  &lt;view class=&quot;item&quot;&gt;
    &lt;text&gt;序号&lt;/text&gt;
    &lt;text&gt;姓名&lt;/text&gt;
    &lt;text&gt;年龄&lt;/text&gt;
    &lt;text&gt;性别&lt;/text&gt;
  &lt;/view&gt;
  &lt;view
    class=&quot;item&quot;
    wx:for=&quot;{{students}}&quot;
    wx:key=&quot;name&quot;
  &gt;
    &lt;text&gt;{{index + 1}}&lt;/text&gt;
    &lt;text&gt;{{item.name}}&lt;/text&gt;
    &lt;text&gt;{{item.age}}&lt;/text&gt;
    &lt;text&gt;{{item.gender}}&lt;/text&gt;
  &lt;/view&gt;
&lt;/view&gt;
+ &lt;view wx:else&gt; 暂无数据... &lt;/view&gt;
</code></pre>

        <h3>1.3.2 hidden</h3>

        <blockquote>
            <p>除了使用 <code>wx:if</code> 来控制元素的显示外，还可以使用 <code>hidden</code> 属性来实现相同的结果。</p>
        </blockquote>

        <pre><code>
// pages/index/index.js
// 调用 Page 函数
Page({
  data: {
    seen: true,
  },
  toggle() {
    // 切换 seen 的值
    this.setData({
      seen: !this.data.seen,
    })
  },
})
</code></pre>

        <pre><code>
&lt;!-- 条件数据渲染 --&gt;
&lt;button type=&quot;primary&quot; bind:tap=&quot;toggle&quot;&gt;显示/隐藏&lt;/button&gt;
&lt;view wx:if=&quot;{{seen}}&quot;&gt;{{msg}}&lt;/view&gt;
&lt;view hidden=&quot;{{!seen}}&quot;&gt;{{msg}}&lt;/view&gt;
</code></pre>

        <p>对比 <code>wx:if</code> 和 <code>hidden</code> 二者的区别：</p>

        <ul>
            <li>
                <p><code>wx:if</code> 在条件为 <code>true</code> 时会将内容渲染出来，否则不会进行渲染，是通过【添加/删除】节点的方式来实现的。</p>
            </li>
            <li>
                <p><code>hidden</code> 在条件为 <code>true</code> 时会隐藏内容，否则会显示内容，是通过 <code>display</code> 样式属性来实现的。</p>
            </li>
        </ul>

        <h3>1.3.3 block</h3>

        <blockquote>
            <p><code>block</code> 是小程序中一个特殊的标签，用于分组控制页面元素的渲染，通过会配合 <code>wx:for</code> 和 <code>wx:if</code> 来使用，下面举例来说明：</p>
        </blockquote>

        <p>需求：假如满足某个条件是显示多个结构。</p>

        <p>方案：就可以使用block包裹需要控制的多个结构进行控制</p>

        <pre><code>
&lt;block wx:if=&quot;{{isShow}}&quot;&gt;
  &lt;view class=&quot;msg&quot;&gt;{{msg}}&lt;/view&gt;
  &lt;input name=&quot;number&quot; value=&quot;{{number}}&quot; /&gt;
  &lt;view class=&quot;students&quot;&gt;...&lt;/view&gt;
&lt;/block&gt;
</code></pre>

        <p>tip 提示:
            block 标签本身并不会被渲染到页面当中，它一般只用于分组控制内容的渲染，也可以用 wx:for</p>

        <h1>生命周期</h1>

        <p>我们都知道生命周期是一组名称固定且会自动被调用执行的函数，在开发小程序时也有专门的的生命周期函数，分为<strong>应用级别、页面级别和组件级别3种类型</strong>，我们先学习应用级别和页面级别的生命周期。</p>

        <h2>2.1 应用级别</h2>

        <blockquote>
            <p>首先要知道应用级别的生命周期函数定义在 <code>app.js</code> 当中，且生命周期函数的名称及执行情况如下表所示：</p>
        </blockquote>

        <table border="3" cellspacing="0" cellpadding="3">
            <tr>
                <th>生命周期</th>
                <th>必填</th>
                <th>说明</th>
            </tr>
            <tr>
                <td>onLaunch</td>
                <td>否</td>
                <td>监听小程序初始化，全局只会执行 1 次</td>
            </tr>
            <tr>
                <td>onShow</td>
                <td>否</td>
                <td>监听小程序启动或切前台</td>
            </tr>
            <tr>
                <td>onHide</td>
                <td>否</td>
                <td>监听小程序切后台</td>
            </tr>
        </table>

        <h3>2.1.1 基本语法</h3>

        <p>通过代码演示用法：</p>

        <pre><code>
// app.js
App({
  onLaunch() {
    console.log(&#39;小程序启动了，只会执行 1 次！&#39;)
  },
  onShow() {
    console.log(&#39;小程序处于前台状态！&#39;)
  },
  onHide() {
    console.log(&#39;小程序处于后台状态！&#39;)
  },
})
</code></pre>

        <p>tip 提示:</p>

        <ol>
            <li>
                <p>用户在点击右上角的胶囊关闭小程序时，小程序并示被销毁，只是将小程序置于后台运行了，因此小 onLaunch 并不会重复执行。当小程序执行停留在后台约5分钟后小程序会自动被销毁，再次打开小程序时 onLaunch 会再次被执行。</p>
            </li>
            <li>
                <p>通过应用级别的生命周期可以进行一些全局性的设置，如检测用户的登录状态（后期项目中会用到）、获取小程序的场景值等。</p>
            </li>
        </ol>

        <h3>2.1.2 场景值</h3>

        <blockquote>
            <p>所谓的场景描述的是用户打开小程序的方式，如扫码、搜索、分享等，并且每个场景都对应了一个数值，即场景值</p>
        </blockquote>

        <p>根据这个场景值来判断用户打开小程序的方式，进而分析用户的行为，常见的场景值如下表所示：</p>

        <table border="3" cellspacing="0" cellpadding="3">
            <tr>
                <th>场景值 ID</th>
                <th>说明</th>
            </tr>
            <tr>
                <td>1001</td>
                <td>发现栏小程序主入口</td>
            </tr>
            <tr>
                <td>1011</td>
                <td>扫描二维码</td>
            </tr>
            <tr>
                <td>1007</td>
                <td>单人聊天会话中的小程序消息卡片</td>
            </tr>
        </table>

        <p>获取小程序的声景值<strong>只能在全局生周期函数 <code>onLaunch</code>、<code>onShow</code> 中获取</strong>，代码如下所示</p>

        <pre><code>javascript
// app.js
App({
  onLaunch(params) {
    // 1001 发现栏小程序主入口
    // 1011 扫描二维码
    // 单人聊天会话中的小程序消息卡片
    console.log(params.scene)
  },
  onShow(params) {
    // 也可以获取场景值ID
    console.log(params.scene)
  },
})
</code></pre>

        <p>获取到场景值后就可以确定用户是以<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html">何种方式</a>打开小程序了，进而分析用户的行为，帮助管理者制订合理的营销方案。</p>

        <p>举例说明：比如通过场景值发现最近一段时间大量用户是通过分享的方式打开小程序的，那说明用户分享的意愿很强，营销活动有成效，如果用户主动去搜索小程序，说明小程序的知名度和受欢迎程序都比较高等。</p>

        <h2>2.2 页面级别</h2>

        <blockquote>
            <p>页面级别的生命周期函数写在页面对应的页面 <code>.js</code> 当中：</p>
        </blockquote>

        <table border="3" cellspacing="0" cellpadding="3">
            <tr>
                <td>生命周期</td>
                <td>必填</td>
                <td>说明</td>
            </tr>
            <tr>
                <td>onLoad</td>
                <td>否</td>
                <td>监听页面加载，只会执行 1 次</td>
            </tr>
            <tr>
                <td>onShow</td>
                <td>否</td>
                <td>监听页面显示</td>
            </tr>
            <tr>
                <td>onReady</td>
                <td>否</td>
                <td>监听页面初次渲染完成，只会执行 1 次</td>
            </tr>
            <tr>
                <td>onHide</td>
                <td>否</td>
                <td>监听页面隐藏</td>
            </tr>
            <tr>
                <td>onUnload</td>
                <td>否</td>
                <td>监听页面卸载</td>
            </tr>
        </table>

        <h3>2.2.1 基本语法</h3>

        <p>以首页的 <code>.js</code> 为例演示用法：</p>

        <pre><code>
// pages/index/index.js
Page({
// ...省略前面小节的代码
    onShow() {
    // 其次执行
        console.log(&#39;首页处于显示状态...&#39;)
    },

    onReady() {
        console.log(&#39;首页初次渲染完成了...&#39;)
    },

    onLoad() {
        // 最先执行
        console.log(&#39;首页面加载完毕...&#39;)
   },

    onHide() {
        console.log(&#39;首页处于隐藏状态...&#39;)
    },

    onUnload() {
        console.log(&#39;首页面即将卸载...&#39;)
    }
})
        </code></pre>

        <p>通过上述代码的演示大家要掌握页面生命周期的如下特点：</p>

        <ul>
            <li>onLoad 和 onReady 只会执行 1 次</li>
            <li>onShow 和 onHide 会重复执行</li>
            <li>普通链接跳转及切换 Tab 页面不会卸载，页面处理隐藏的状态</li>
        </ul>

        <p>在开发中页面的生命周期函数会使用非常频繁，根据生命周期的不同特性用法也千变万化，我们先来看 <code>onLoad</code> 的一般用法，其它生命周期的应用后续开发中结合需求再做介绍。</p>

        <h3>2.2.2 获取地址参数</h3>

        <blockquote>
            <p>小程序在进行页面跳转时可以在跳转地址上通过 <code>?</code> 来拼凑参数，这些参数通过 <code>onLoad</code> 生命周期函来获取，用法如下所示：</p>
        </blockquote>

        <p>我们在首页面添加一个链接使其跳转到 <code>logs</code> 页面，并且在地址上通过 <code>?</code> 来拼凑一些参数：</p>

        <p><code>
&lt;!-- page/index/index.wxml --&gt;
&lt;!-- 省略前面小节的代码 --&gt;
&lt;navigator url=&quot;/pages/logs/logs?name=小明&amp;age=18&quot;&gt;跳转到日志页面&lt;/navigator&gt;
</code></p>

        <p>小程序中通过地址参数与网页是一致的，格式为 <code>?key1=value1&amp;key2=value2</code>，上述示例只是介绍基本用法，参数并没有实际的意义。</p>

        <p>思考：地址上拼凑的参数是传给哪个页面的？</p>

        <p>很容易判断是传给日志页面的，因此获取地址上的参数应该到日志页面的 <code>onLoad</code> 中获取，代码如下所示：</p>

        <pre><code>
// page/logs/logs.js
Page({
  onLoad(params) {
    // 查看地址中的参数
    console.log(params)
  },
})
</code></pre>

        <p>注意⚠️：<code>open-type=&quot;switchTab&quot;</code>模式跳转不支持query参数</p>

        <h1>内置 API</h1>

        <p>小程序 API 是小程序<strong>内置提供</strong>的一系列的方法，通过这些方法能够实现许多的功能，比如网络请求、消息提示、本地存储、微信登录、微信支付等，这些 API 通过全局对象
            <code>wx</code> 进行调用。</p>

        <h2>3.1 网络请求</h2>

        <blockquote>
            <p><code>wx.request</code> API 是用来发起网络请求的，类似于网页中的 <code>ajax</code>，其用法如下所示：</p>
        </blockquote>

        <p><strong>语法：</strong><code>wx.request(config:object)</code></p>

        <pre><code>
// pages/index/index.js
// 小程序发起网络请求（调用接口）的方法
wx.request({
  // 接口地址
  url: &#39;api/path/xxx&#39;,
  // 请求的方法
  method: &#39;GET｜POST|PUT&#39;,
  // 请求时的数据
  data: {},
  success(res) {
    // 成功响应的回调
  },
  // ...
})
</code></pre>

        <h3>3.1.1 获取学生列表</h3>

        <p>我们以获取学生列表数据为例来练习 <code>wx.request</code> 的使用：</p>

        <pre><code>
// pages/index/index.js
Page({
  // ...前面小节代码省略
  onLoad() {
    // 页面加载完成即获取学生列表
    this.getStudentList()
  },
  // 获取学生表表
  getStudentList() {
    // 调用小程序 api
    wx.request({
      url: &#39;https://mock.boxuegu.com/mock/3293/students&#39;,
      method: &#39;GET&#39;,
      success: (res) =&gt; {
        console.log(res)
      },
    })
  },
})
</code></pre>

        <p>非常不幸，上述代码的执行时会报告一个错误，如下图：</p>

        <p><img alt="错误提示" src="./images/weixin/picture_2-9624490.jpg" /></p>

        <p>小程序规定 <code>wx.request</code> 调用接口的服务器地址（域名）必须事先在小程序的管理后台进行设置，否则是不允许发起网络请求，如何解决这个问题呢？有两种方式：</p>

        <ul>
            <li>在小程序管理后台进行设置</li>
            <li>在小程序开发工具中进行设置</li>
        </ul>

        <p>管理后台设置步骤见下图：</p>

        <p><img alt="" src="./images/weixin/picture_3-9624490.jpg" /></p>

        <p>warning 注意:
            域名有个严格的要求：<strong>必须</strong>是 <code>https</code> 协议且已备案！</p>

        <p>在开发工具中设置步骤如下：</p>

        <p><img alt="" src="./images/weixin/picture_6-9624490.jpg" /></p>

        <p>warning 注意:
            在开发工具中设置的方式只适用于开发环境，即只能在小程序开发者工具中生效。</p>

        <p><strong>调用 <code>wx.request</code> 发起请求成功响应后返回的数据格式为：</strong></p>

        <pre><code>
{
  cookies: []
  data: {}
  errMsg: &quot;request:ok&quot;
  header: {}
  statusCode: 200
}
</code></pre>

        <p>tip 提示:
            上述演示接口返回的学生列表信息是随机生成的，即每次调用的结果都是不相同的。</p>

        <h2>3.2 界面交互</h2>

        <p>小程序还提供了一些用于界面交互的 API，如加载提示、信息反馈、确认框等。</p>

        <h3>3.2.1 加载提示</h3>

        <blockquote>
            <p>加载提示框常配合网络请求来使用，用于增加用户体验，对应的 API 有两个，分别为：</p>
        </blockquote>

        <ul>
            <li><code>wx.showLoading</code> 显示加载提示框</li>
            <li><code>wx.hideLoading</code> 隐藏加载提示框</li>
        </ul>

        <p>它们的语法如下：</p>

        <pre><code>
// 显示加载提示
wx.showLoading({
  title: &#39;正在加载...&#39;,
  mask: true,
})
// 隐藏加载提示
wx.hideLoading()
        </code></pre>

        <p>结合上一节获取学生列表来演示这两个 API 的使用：</p>

        <pre><code>
// pages/index/index.js
Page({
    // ...省略前面小节代码
    // 获取学生表表
    getStudentList() {
        // 显示提示框
// + wx.showLoading({
// + title: &#39;正在加载...&#39;
// + })
    // 发起请求
    wx.request
      url: &#39;https://mock.boxuegu.com/mock/3293/students&#39;,
      method: &#39;GET&#39;,
      // 这里注意因为 this 的原因，推荐使用箭头函数
      success: (res) =&gt; {
        this.setData({
          // 更新 students 数组
          students: res.data.result,
        })
      },
      complete() {
        // 隐藏提示框
// wx.hideLoading()
        
            },
        })
     },
})
            </code></pre>


        <p>在调用 <code>wx.showLoading</code> 时可以传入以下参数：</p>

        <ul>
            <li><code>title</code> 指定显示的文字提示内容（不能省略）</li>
            <li><code>mask</code> 提供一个透明层阻止对页面其它内容进行操作</li>
            <li><code>success</code> 显示加载提示框成功后的回调（很少用到）</li>
            <li><code>fail</code> 显示加载提示框失败后的回调（很少用到）</li>
            <li><code>complete</code> 显示加载提示框完成后的回调（包括成功和失败两种情况）</li>
        </ul>

        <h3>3.2.2 信息反馈</h3>

        <blockquote>
            <p>信息反馈是指根据用户的某些操作来告知操作的结果，如用户点击加入购物车，提示用户添加成功，用户提交表单提示用户表单验证的结果等，对应的 API 是 <code>wx.showToast</code></p>
        </blockquote>

        <p>其语法如下：</p>

        <pre><code>
wx.showToast({
  title: &#39;姓名只能为汉字!&#39;,
  duration: 2000,
  mask: true,
  icon: &#39;success&#39;
})
        </code></pre>

        <p>以表单验证举例说明 API 的使用：</p>

        <pre><code>
&lt;!-- pages/index/index.wxml --&gt;
&lt;!-- 省略了部分代码 --&gt;
&lt;input type=&quot;text&quot; model:value=&quot;{{username}}&quot; placeholder=&quot;请填写您的姓名&quot; /&gt;
&lt;button type=&quot;primary&quot; bind:tap=&quot;submitForm&quot;&gt;提交&lt;/button&gt;
        </code></pre>

        <pre><code>
// 调用 Page 函数
// pages/index/index
Page({
    data: {
        username: &#39;&#39;,
    },
    submitForm() {
        console.log(this.data.username);
        // 验证用户名只能由英文、数字、下划线组成
        const reg = /^\w+$/;
        // 验证结果
        const valid = reg.test(this.data.username.trim());
        // 提示验证结果
        if (!valid) {
            return wx.showToast({
                title: &#39;用户名只能由英文、数字、下划线组成!&#39;,
                icon: &#39;none&#39;,
            });
        }
    },
});
            </pre></code>

        <p>在调用 <code>wx.showToast</code> 时可以传入以下参数：</p>

        <ul>
            <li><code>title</code> 指定显示的文字提示内容（不能省略）</li>
            <li><code>mask</code> 提供一个透明层阻止对页面其它内容进行操作</li>
            <li><code>icon</code> 指定图标类型</li>
            <li><code>duration</code> 指定信息反馈的显示时长</li>
        </ul>

        <h2>3.3 本地存储</h2>

        <blockquote>
            <p>小程序中也能够像网页一样支持本地存储数据，用于在本地存一些临时性的数据，比如包含的用户登录状态 token 等，其包含以下 4个主要的 API：</p>
        </blockquote>

        <ul>
            <li><code>wx.setStorageSync</code> 在本地存入一个数据</li>
            <li><code>wx.getStorageSync</code> 读取本地的一个数据</li>
            <li><code>wx.removeStorageSync</code> 删除本地存储的一个数据</li>
            <li><code>wx.clearStorageSync</code> 清空本地存储的数据</li>
        </ul>

        <p>tip 提示:
            在小程序中 <code>Sync</code> 结尾的 API 指的是同步方式执行，同步方式执行的 API 在使用时简洁比较好，但缺点是同步会阻塞程序执行，执行效率上相较异步版本要差一些。</p>

        <h3>3.3.1 存入数据</h3>

        <blockquote>
            <p>如下代码所示调用 API <code>wx.setStorageSync</code> 在小程序本地存入数据</p>
        </blockquote>

        <pre><code>
// pages/storage/index.js
Page({
  // 存入本地数据
  setStorage() {
    wx.setStorageSync(&#39;name&#39;, &#39;小明&#39;)
    // 可以直接存入对象，无需 JSON.stringify 处理
    wx.setStorageSync(&#39;user&#39;, { name: &#39;小明&#39;, age: 18 })
  },
})
        </code></pre>

        <p>tip
            注意在小程序中本地存储可以直接存入对象或数组类型的数据，无需要 <code>JSON.stringify</code> 进行处理。</p>

        <h3>3.3.2 读取数据</h3>

        <blockquote>
            <p>如下代码所示调用 API <code>wx.getStorageSync</code> 读取本地存储中的数据</p>
        </blockquote>

        <pre><code>
// pages/storage/index.js
Page({
  // 存入本地数据
  setStorage() {
    wx.setStorageSync(&#39;name&#39;, &#39;小明&#39;)
    // 可以直接存入对象，无需 JSON.stringify 处理
    wx.setStorageSync(&#39;user&#39;, { name: &#39;小明&#39;, age: 18 })
  },
  // 读取本地数据
  getStorage() {
    const name = wx.getStorageSync(&#39;name&#39;)
    // 对象类型的数据不必 JSON.parse 处理
    const user = wx.getStorageSync(&#39;user&#39;)
  },
})
        </code></pre>

        <p>tip
            注意由于存入本地的数据并没有进行 <code>JSON.stringify</code> 处理，因此取出来的数据也不必进行 <code>JSON.parase</code> 处理了。</p>

        <h3>3.3.3 删除数据</h3>

        <blockquote>
            <p>如下代码所示调用 API <code>wx.removeStorageSync</code> 删除本地存储的数据</p>
        </blockquote>

        <pre><code>
// pages/storage/index.js
Page({
  // 存入本地数据
  setStorage() {
    wx.setStorageSync(&#39;name&#39;, &#39;小明&#39;)
    // 可以直接存入对象，无需 JSON.stringify 处理
    wx.setStorageSync(&#39;user&#39;, { name: &#39;小明&#39;, age: 18 })
  },
  // 读取本地数据
  getStorage() {
    const name = wx.getStorageSync(&#39;name&#39;)
    // 对象类型的数据不必 JSON.parse 处理
    const user = wx.getStorageSync(&#39;user&#39;)
  },
  // 删除数据
  removeStorage() {
    wx.removeStorageSync(&#39;name&#39;)
  },
  // 清空数据
  clearStorage() {
    wx.clearStorageSync()
  },
})
        </code></pre>

        <h3>3.3.4 清空数据</h3>

        <blockquote>
            <p>如下代码所示调用 API <code>wx.clearStorageSync</code> 删除本地存储的数据</p>
        </blockquote>

        <pre><code>
// pages/storage/index.js
Page({
  // 存入本地数据
  setStorage() {
    wx.setStorageSync(&#39;name&#39;, &#39;小明&#39;)
    // 可以直接存入对象，无需 JSON.stringify 处理
    wx.setStorageSync(&#39;user&#39;, { name: &#39;小明&#39;, age: 18 })
  },
  // 读取本地数据
  getStorage() {
    const name = wx.getStorageSync(&#39;name&#39;)
    // 对象类型的数据不必 JSON.parse 处理
    const user = wx.getStorageSync(&#39;user&#39;)
  },
  // 删除数据
  removeStorage() {
    wx.removeStorageSync(&#39;name&#39;)
  },
  // 清空数据
  clearStorage() {
    wx.clearStorageSync()
  },
})
        </code></pre>

        <blockquote>
            <p>除了上述的4个 API 外，还有4个与之对应的异步版本的API：</p>
        </blockquote>

        <ul>
            <li><code>wx.setStorage</code> 在本地存入一个数据</li>
            <li><code>wx.getStorage</code> 读取本地的一个数据</li>
            <li><code>wx.removeStorage</code> 删除本地存储的一个数据</li>
            <li><code>wx.clearStorage</code> 清空本地存储的数据</li>
        </ul>

        <p>调用异步方式的 API 传入的是一个对象类型的参数：</p>

        <pre><code>
Page({
  setStorage() {
    wx.setStorage({
      key: &#39;name&#39;,
      data: &#39;小明&#39;
    })
    // 等同于
    wx.setStorage(&#39;name&#39;, &#39;小明&#39;)
  }
})
</code></pre>

        <p>tip 提示:
            在小程序中 <code>Sync</code> 结尾的 API 指的是同步方式执行，同步方式执行的 API 在使用时简洁比较好，但缺点是同步会阻塞程序执行，执行效率上相较异步版本要差一些。</p>

        <h2>3.4 头像昵称填写</h2>

        <p>小程序开发过程中获取用户昵称和头像是比较常见的功能，新建一个页面 <code>profile</code> 来演示该功能的实现步骤。</p>

        <h3>3.4.1 用户头像</h3>

        <blockquote>
            <p><strong>获取用户头像必须用到 <code>button</code> 组件，且用户必须要主动点击 <code>button</code> 按钮，以下是 <code>button</code>
                    的使用细节：</strong></p>
        </blockquote>

        <ul>
            <li>设置 <code>button</code> 的属性 <code>open-type</code> 值为 <code>chooseAvatar</code></li>
            <li>监听 <code>button</code> 的 <code>chooseavatar</code> 事件</li>
        </ul>

        <p>warning 注意:
            open-type 的属性值 chooseAvatar (有大写字母)，事件类型 chooseavatar (全部小写字母)。</p>

        <p>说明⚠️：基础库2.21.2支持</p>
            <img src="./images/weixin/image-20221130162304420.png" style="zoom:50%;" alt="">

        <p>如上图所示用户点击了按钮后会弹出一个选择列表，无论是选择微信头像、相册选择、还是拍照都会触发事件 <code>chooseavatar</code>，在事件回调函数中来获取用户头像的图片地址数据。</p>

        <p>在事件回调 <code>getUserAvatar</code> 中获取到用户的头像地址，通过这个地址就可以将用户设置的头像展示到页面当中了。</p>

        <pre><code>
&lt;view class=&quot;profile&quot;&gt;
  &lt;image src=&quot;{{profile.avatarUrl}}&quot;&gt;&lt;/image&gt;
  &lt;button type=&quot;warn&quot; open-type=&quot;chooseAvatar&quot; bindchooseavatar=&quot;getUserAvatar&quot;&gt;
    头像
  &lt;/button&gt;
&lt;/view&gt;
</code></pre>

        <pre><code>
// pages/profile/index.js
Page({
  data: {
    profile: {
      avatarUrl: &#39;/static/images/avatar.png&#39;,
      nickName: &#39;微信用户&#39;,
    },
  },
  // 获取用户头像
  getUserAvatar(ev) {
    // 获取头像对应的地址
    // console.log(ev.detail.avatarUrl)
    this.setData({
      &#39;profile.avatarUrl&#39;: ev.detail.avatarUrl,
    })
  },
})
</code></pre>

        <p>同学们有没有注意到上面代码中调用 <code>setData</code> 时使用了 <code>&#39;profile.avatarUrl&#39;</code>
            ，这是小程序特别支持更新数据的用法，它等同于下面的写法：</p>

        <pre><code>
this.setData({
  // 这种写法没有上述语法简洁
  profile: {
    avatarUrl: ev.detail.avatarUrl,
  },
})
</code></pre>

        <p><strong>此时得到的头像地址是临时地址，只能在小程序内部使用，要实现永久存储需要将这个图片上传给自已的服务端，文件上传会用到 <code>wx.uploadFile</code>。</strong></p>

        <pre><code>
// pages/profile/index.js
Page({
    // 省略部分代码...
    getUserAvatar(ev) {
        this.setData({
            &#39;profile.avatarUrl&#39;: ev.detail.avatarUrl,
        });
        // 上传临时文件
        wx.uploadFile({
            url: &#39;http://ajax-api.itheima.net/api/file&#39;,
            filePath: ev.detail.avatarUrl,
            name: &#39;avatar&#39;,
            success: (res) =&gt; {
                console.log(res);
            },
        });
    },
})
        </code></pre>



        <p>选择头像组件存在的问题❓：</p>

        <ol>
            <li>
                <p>拍照报错提示：&quot;设置失败，请重试&quot;</p>
            </li>
            <li>
                <p>相册选取照片报错提示：&quot;无法使用该头像&quot;</p>
            </li>
        </ol>

        <h3>3.4.2 用户昵称</h3>

        <blockquote>
            <p><strong>获取用户昵称必须用到 <code>input</code> 组件，当 <code>input</code> 获得焦点后小程序会自动展示用户的昵称 以下是 <code>input</code>的使用细节：</strong></p>
        </blockquote>

        <ul>
            <li>设置 <code>input</code> 的 <code>type</code> 属性值为 <code>nickname</code></li>
            <li>监听 <code>input</code> 组件的 <code>input</code> 、<code>blur</code> 、<code>change</code> 等事件获取表单中的值</li>
        </ul>

        <img src="./images/weixin/image-20221130173950165.png" style="zoom: 50%;" alt="">

        <p>如上图所示当 <code>input</code> 组件获得焦点时，页面的底部自动弹出用户默认的昵称，用户选择后会自动填入表单当中，用户也可以在表单中填写内容对昵称进行自定义。</p>

        <blockquote>
            <p>那如何获取用户在表单中填写的用户昵称呢？</p>
        </blockquote>

        <p>用户在表单中填写的内容（昵称）需要事件回调中通过失去焦点blur事件对象来获取</p>

        <pre><code>
&lt;input type=&quot;nickname&quot; bind:blur=&quot;getUserNickName&quot; /&gt;
        </code></pre>

        <p>在事件回调 getUserNickName 中获取到用户昵称，然后将昵称展示到页面当中。</p>

            <pre><code>
// pages/profile/index.js
Page({
    data: {
        profile: {
            avatarUrl: &#39;/static/images/avatar.png&#39;,
            nickName: &#39;微信用户&#39;,
        },
    },
    // 获取用户头像...

    // 获取昵称
    getUserNickName(ev) {
        // 获取用户设置的昵称
        this.setData({
            &#39;profile.nickName&#39;: ev.detail.value,
        })
    },
})
            </code></pre>
            

        <p>练习：将获取到的用户头像和昵称存入小程序本地。</p>

        <h2>3.5 路由</h2>

        <p>小程序中的路由其实单纯只是页面的跳转，一般在页面中使用 <code>navigator</code> 组件来实现，也有很多场景需要在 js 中根据逻辑的执行结果跳转到某个页面，比如检测到用户尚未登录就跳转到登录页面。</p>

        <h3>3.5.1 wx.navigateTo</h3>

        <blockquote>
            <p><code>wx.navigateTo</code> 跳转到一个新的页面，会新增一种历史记录</p>
        </blockquote>

        <pre><code>
// /pages/router/index.js
Page({
  // 普通的跳转
  navigateTo() {
    wx.navigateTo({
      url: &#39;/pages/logs/logs?name=小刚&amp;age=19&#39;,
      success() {}
    });
  },
})
        </code></pre>

        <p>通过 <code>wx.navigateTo</code> 跳转页面通过左上角的能够实现返回操作，如果要跳转的页面路径是一个 tabBar 的页时，不能使用 <code>wx.navigateTo</code>。
        </p>

        <h3>3.5.2 wx.redirectTo</h3>

        <p><code>wx.redirectTo</code> 跳转到一个新的页面，<strong>不会新增一种历史记录</strong>，替换掉当前页面。</p>

        <pre><code>javascript
// /pages/router/index.js
Page({
  // 和 navigateTo 很类似，区别在于不会新增历史记录
  redirectTo() {
    wx.redirectTo({
      url: &#39;/pages/logs/logs?name=小刚&amp;age=19&#39;,
    });
  },
});
</code></pre>

        <h3>3.5.5 wx.navigateBack</h3>

        <p><code>wx.navigateBack</code> 返回页面。</p>

        <pre><code>
// /pages/router/index.js
    Page({
        // 返回页面
        navigateBack() {
            wx.navigateBack();
        },
    });
        </code></pre>
        

        <h2>3.6 其它</h2>

        <p>总结：</p>

        <ol>
            <li>
                <p>小程序中大部分的 API 都是异步方式执行，异步 API 传入的都是对象类型的参数，且都可以传入
                    <code>success</code>、<code>fail</code>、<code>complete</code> 回调函数。</p>
            </li>
            <li>
                <p>也有少部分 API 是同步方式执行，同步方式的 API 有个特点就是均以 <code>Sync</code> 结尾。</p>
            </li>
            <li>善于利用文档</li>
        </ol>

        <h1>npm 支持</h1>

        <h2>4.1 默认构建</h2>

        <blockquote>
            <p>小程序不能直接使用在 npm 下载的模块包，必须经过小程序开发者工具进行构建后才可以使用，这一节我们来学习支持 npm 模块包的步骤：</p>
        </blockquote>

        <ol>
            <li>打开终端窗口</li>
        </ol>

        <img src="./images/weixin/image-20221130181511711.png" style="zoom: 50%;" alt="">

        <ol>
            <li>安装一个 npm 模块包，以 <code>dayjs</code> 为例</li>
        </ol>

        <p><code></code>`bash</p>

        <h1>创建 package.json</h1>

        <p>npm init -y</p>

        <h1>安装一个模块</h1>

        <p><pre><code>npm install dayjs</code></pre></p>

        <p>这一步操作是与以往的 npm 模块安装没有任何的区别，会将模块安装到 <code>node_modules</code> 当中，但是下载的模块无法直接导入到小程序中，如下图所示：</p>

        <img src="./images/weixin/image-20221130181838197.png" style="zoom: 50%;" alt="">

        <ol>
            <li>构建 npm，步骤如下图所示</li>
        </ol>

        <img src="./images/weixin/image-20221130182022786.png" style="zoom: 50%;" alt="">

        <p>构建 npm 的结果会创建一个新的目录 <code>miniprogram_npm</code> 把构建后的 npm 模块放到了这个目录之下，此时在小程序中便可以成功导入 npm 的模块包了。</p>

        <h2>4.2 自定义构建</h2>

        <blockquote>
            <p>默认情况下项目目录的最外层是小程序的根目录，通过 <code>project.config.json</code> 可以指定小程序的根目录，这样做的好处是能够优化目录结构，更好的管理项目的代码:</p>
        </blockquote>

        <p>场景：</p>

        <ol>
            <li>
                <p>1.公司中小程序代码单独放到一个目录维护，这时候需要自定义项目根目录</p>
                <pre><code>
{
    "setting": {
      ...
    },
  + "miniprogramRoot": "src/",
    "compileType": "miniprogram",
    "libVersion": "2.19.4",
    "appid": "wx3eb80995b7e84924",
    "projectname": "demo",
}  
                </code></pre>
            </li>

            <li>
                <p>2.如果项目中有npm依赖，也需要自定义npm目录</p>
                <pre><code>
{
    "setting": {
  //-    "ignoreDevUnusedFiles": false,
  //-    "ignoreUploadUnusedFiles": false,
      ...
  //+    "packNpmManually": true,
  //+    "packNpmRelationList": [
        {
  //+        "packageJsonPath": "./package.json",
  //+        "miniprogramNpmDistDir": "./src"
        }
      ],
      ...
    },
    "libVersion": "2.19.4",
    "miniprogramRoot": "src/",
    "compileType": "miniprogram",
    "appid": "wx3eb80995b7e84924",
    "projectname": "demo",
}
                </code></pre>
            </li>
        </ol>

        <p>说明：</p>

        <ul>
            <li><code>miniprogramRoot</code> 自定义小程序的根目录</li>
            <li><code>packNpmManually</code> 启用 npm 构建手动配置</li>
            <li><code>packNpmRelationList</code> 手动构建 npm 配置详情：</li>
            <li><code>packageJsonPath</code>包管理文件位置</li>
            <li><code>miniprogramNpmDistDir</code>构建npm文件存储位置</li>
        </ul>

        <p>问题：<a href="https://developers.weixin.qq.com/community/develop/article/doc/00020631afc6c8c6f62e7b91855c13?idescene=6">如何解决“Error:xxx.js 已被代码依赖分析忽略，无法被其他模块引用”报错？</a></p>

        <h1>自定义组件</h1>

        <p>小程序有许多的<a href="https://developers.weixin.qq.com/miniprogram/dev/component/">内置组件</a>，比如之前学习过的
            <code>view</code>、<code>image</code>、<code>scroll-view</code>、<code>swiper</code>等，除此之外小程序也允许开发者自定义组件。</p>

        <h2>5.1 组件基础</h2>

        <blockquote>
            <p>自定义组件的结构与页面是一致的，即也包含有4个部分，分别为:</p>
        </blockquote>

        <ul>
            <li><code>.wxml</code> 组件的布局结构</li>
            <li><code>.js</code> 组件的处理逻辑</li>
            <li><code>.json</code> 组件的配置文件</li>
            <li><code>.wxss</code> 组件的布局样式</li>
        </ul>

        <h3>5.1.1 创建组件</h3>

        <blockquote>
            <p>通常习惯将组件放到独立的目录 <code>components</code> 当中，这个目录需要我们手动进行创建。</p>
        </blockquote>

        <p>创建一个叫 <code>authorization</code> 的组件来学习组件创建的步骤，在 <code>components</code> 目录中新建 <code>authorization</code>
            目录，然后在右键在菜单中找到【新建 Component】，输入<strong>组件名称</strong>后会自动创建组件。</p>

            <img src="./images/weixin/image-20221201163554282.png" style="zoom: 50%;" alt="">

        <blockquote>
            <p>组件和页面的结构是一致的，但也是有区别的，先简单有个了解：</p>
        </blockquote>

        <ul>
            <li>组件的配置文件中配置项 <code>component: true</code></li>
            <li>组件的 <code>.js</code> 文件中调用 <code>Component</code> 函数</li>
        </ul>

        <h3>5.1.2 注册组件</h3>

        <blockquote>
            <p>组件的注册分为<strong>页面注册</strong>和<strong>全局注册</strong>两种情况：</p>
        </blockquote>

        <ol>
            <li>页面注册是在使用组件的页面配置中通过 <code>usingComponents</code> 进行注册，只能在当前页面中使用注册的组件，如下代码所示：</li>
        </ol>

        <pre><code>
{
  &quot;usingComponents&quot;: {
    &quot;authorization&quot;: &quot;/components/authorization/index&quot;
  }
}
        </code></pre>

        <pre><code>
&lt;!-- pages/index/index.wxml --&gt;
&lt;!-- 双标签用法 --&gt;
&lt;authorization&gt;&lt;/authorization&gt;
&lt;!-- 单标签用法(一定要闭合) --&gt;
&lt;authorization /&gt;
        </code></pre>

        <ol>
            <li>全局注册是在 <code>app.json</code> 文件中通过 <code>usingComponents</code> 对自定义组件进行注册，注册的组件可以任意页面中使用全局注册的组件，如下代码所示：</li>
        </ol>

        <pre><code>
{
  &quot;pages&quot;: [...],
  &quot;window&quot;: {...},
//+  &quot;usingComponents&quot;: {
//+    &quot;authorization&quot;: &quot;/components/authorization/index&quot;
//+  },
  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;
}
        </code></pre>

        <p>以上示例重点演示了组件的创建及注册步骤，组件功能并不同我们的重心，因此关于组件的布局结构、样式以并未详细展开，不过关于布局和样式部分和页面并没有太大的差别，同学们课下自行练习一下。</p>

        <p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/">文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/</a></p>

        <h2>5.2 组件进阶</h2>

        <p>本节来学习如何处理组件的逻辑。</p>

        <h3>5.2.1 数据变量和方法</h3>

        <blockquote>
            <p>了解数据变量、方法定义和使用</p>
        </blockquote>

        <ul>
            <li><code>data</code> 组件本身内部定义的数据</li>
            <li><code>methods</code>中定义组件的方法</li>
        </ul>

        <pre><code>
// components/authorization/index
Component({
  // 初始组件内部数据
  data: {
    message: &#39;组件中初始的数据&#39;
  },
  methods: {
    // 定义事件回调函数
    handlerClick() {
   	  console.log(&#39;clicked&#39;)
    },
  },
})
</code></pre>

        <h3>5.2.2 组件通信</h3>

        <blockquote>
            <p>自定义组件有自已的作用域，然而在实际开发中，父子组件之间的数据传递是不可避免的。</p>
        </blockquote>

        <h4>父传子</h4>

        <ol>
            <li>父组件通过属性赋值为子组件传递数组</li>
        </ol>

        <pre><code>
&lt;!-- pages/index/index.wxml --&gt;
&lt;view class=&quot;box&quot;&gt;
   &lt;!-- 应用自定义组件 --&gt;
  &lt;header isLogin=&quot;{{true}}&quot; tips=&quot;{{msg}}&quot; /&gt;
&lt;/view&gt;
        </code></pre>

        <ol>
            <li>子组件通过<code>properties</code>接收父组件数据</li>
        </ol>

        <pre><code>
Component({
  // 接收父组件数据
  properties: {
    isLogin: Boolean, 
    tips: {
      // 属性的数据类型
      type: String,
      // 属性的默认值
      value: &#39;hello&#39;
    }
  },
})
        </code></pre>

        <ol>
            <li>查看或调试传入组件的数据与页面数据的查看方式不同，具体查看如下图所示：
                说明❓：选中要查看的组件，通过右侧component data面板查看</li>
        </ol>

        <p><img alt="image-20221201174645441" style="zoom: 50%;" src="./images/weixin/image-20221201174645441.png" /></p>

        <p>注意：可以直接修改父组件传递的数据（父组件不受影响）</p>

        <h4>子传父</h4>

        <ol>
            <li>
                <p>父组件在子组件上绑定自定义事件，提供自定义事件回调方法</p>
                <p>在自定义事件回调方法中，通过默认形参<code>event.detail</code>获取数据</p>
            </li>
        </ol>

        <pre><code>
&lt;!-- pages/index/index.wxml --&gt;
&lt;view class=&quot;box&quot;&gt;
   &lt;!-- 应用自定义组件 --&gt;
  &lt;header isLogin=&quot;{{true}}&quot; tips=&quot;{{msg}}&quot;
 + bind:事件名=&quot;mycallback&quot; /&gt;
&lt;/view&gt;
        </code></pre>

        <pre><code>
// pages/index/index.js
Page({
  // 父组件中的数据
  data: {
  },
  // 自定义事件的回调
//+  mycallback: function (e) {
//+    console.log(&#39;我是父组件中的回调函数...&#39;,e);
//+  }
})
        </code></pre>

        <ol>
            <li>
                <p>子组件触发父组件自定义事件</p>
                <p>通过<code>this.triggerEvent(&#39;自定义事件名称&#39;,data)</code>触发和传递数据</p>
            </li>
        </ol>

        <pre><code>
// components/header/index.js
Component({
  // ...
  // 组件方法，可用于事件监听回调函数
  methods: {
    sayHi: function () {
      // 并且将 {name: &#39;小明&#39;, age: 18} 做为参数，传给父组件自定义事件的回调函数
//+      this.triggerEvent(&#39;事件名&#39;, {name: &#39;小明&#39;, age: 18});
    }
  }
})
</code></pre>

        <h3>5.2.3 生命周期</h3>

        <blockquote>
            <p>前面我们分别学习了应用级别和页面级别的生命周期，组件也有生命周期函数，通过 <code>lifetimes</code> 来定义，主要的生命周期函数有：</p>
        </blockquote>

        <ul>
            <li><code>attached</code> 在组件实例进入页面节点树时执行</li>
            <li><code>detached</code>在组件实例被从页面节点树移除时执行</li>
        </ul>

        <pre><code>
// components/authorization/index.js
Component({
  // ...
  // 组件生命周期
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
});
        </code></pre>

        <h3>扩展-组件模板</h3>

        <blockquote>
            <p>小程序的组件模板其实就是插槽功能，通过 <code>&lt;slot&gt;</code> 在组件内部定义插槽位置，以 <code>authorization</code> 组件为例其用法如下所示：</p>
        </blockquote>

        <ol>
            <li>在组件内定定义 <code>slot</code> 插槽，插槽其实就是个占位符号</li>
        </ol>

        <pre><code>
&lt;view class=&quot;container&quot;&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/view&gt;
        </code></pre>

        <ol>
            <li>在首页面应用组件并在组件开始和结束位置中间插入内容，被插入的内容就会被渲染到插槽的位置上：</li>
        </ol>

        <pre><code>
&lt;authorization is-login=&quot;{{true}}&quot; tips=&quot;用户未登录&quot;&gt;
  &lt;view&gt;默认slot 插槽&lt;/view&gt;
  &lt;view&gt;默认slot 插槽&lt;/view&gt;
&lt;/authorization&gt;
        </code></pre>

        <blockquote>
            <p>默认情况小程序在一个组件中只能支持一个插槽，如果需要多个插槽需要启用多 <code>slot</code> 支持，启用方式如下所示：</p>
        </blockquote>

        <ol>
            <li>启用多插槽支持</li>
        </ol>

        <pre><code>
Component({
  options: {
    // 启用多插槽支持
    multipleSlots: true
  }
  // ...
})
        </code></pre>

        <ol>
            <li>启用了多插槽支持后通过 <code>name</code> 为插槽命名：</li>
        </ol>

        <pre><code>
&lt;view class=&quot;container&quot;&gt;
  &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;
&lt;/view&gt;
&lt;view class=&quot;layout&quot;&gt;
  &lt;slot name=&quot;number&quot;&gt;&lt;/slot&gt;
&lt;/view&gt;
        </code></pre>

        <ol>
            <li>在应用组件时通过 <code>slot</code> 属性指定将内容放入哪个插槽的位置：</li>
        </ol>

        <pre><code>
&lt;authorization is-login=&quot;{{true}}&quot; tips=&quot;用户未登录&quot;&gt;
  &lt;view slot=&quot;content&quot;&gt;
    &lt;view&gt;具名slot 插槽的位置&lt;/view&gt;
    &lt;view&gt;具名slot 插槽的位置&lt;/view&gt;
  &lt;/view&gt;
  &lt;text slot=&quot;number&quot;&gt;1000&lt;/text&gt;
&lt;/authorization&gt;
        </code></pre>

        <h2>5.3 Vant 组件</h2>

        <p>Vant 提供了微信小程序版本的<a href="https://vant-contrib.gitee.io/vant-weapp/#/home">组件库</a>，它本质上就是自定义的小程序组件，我们来学习如何在小程序中引入 Vant 组件库。</p>

        <h3>5.3.1 快速上手</h3>

        <p>第 1 步：安装 vant 组件库</p>

        <pre><code>
npm i @vant/weapp -S --production
        </code></pre>

        <p>第 2 步：如下图所示构建 Vant 组件库，构建时会去检查 <code>package.json</code> 中记录的依赖，因此一定要有 <code>package.json</code> 文件的存在。</p>

        <img src="./images/weixin/image-20221130182022786.png" style="zoom: 50%;" alt="">

        <p>第 3 步：以按钮组件为例，演示使用 Vant 组件的使用方法，推荐全局注册组件 Vant 组件</p>

        <pre><code>
{
  &quot;usingComponents&quot;: {
    &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;
  }
}
        </code></pre>

        <p>注意：将 app.json 中的 <code>&quot;style&quot;: &quot;v2&quot;</code> 去除，小程序的<a
                href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#style">新版基础组件</a>强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。
        </p>

        <h3>5.3.2 Cell 单元格</h3>

        <blockquote>
            <p>介绍常用组件使用方法</p>
        </blockquote>

        <ol>
            <li>首先要在 <code>app.json</code> 中全局注册组件：</li>
        </ol>

        <pre><code>
{
  &quot;usingComponents&quot;: {
    &quot;van-cell&quot;: &quot;@vant/weapp/cell/index&quot;,
    &quot;van-cell-group&quot;: &quot;@vant/weapp/cell-group/index&quot;
  }
}
        </code></pre>

        <ol>
            <li><code>van-cell</code> 组件可以独立使用，也可以配置 <code>van-cell-group</code> 一起使用：</li>
        </ol>

        <pre><code>
&lt;van-cell-group custom-class=&quot;cell-group&quot; inset&gt;
  &lt;van-cell size=&quot;large&quot; title=&quot;北京富力家园&quot;&gt;
    &lt;text class=&quot;tags fail&quot;&gt;审核失败&lt;/text&gt;
  &lt;/van-cell&gt;
  &lt;van-cell title=&quot;房间号&quot; value=&quot;1号楼1单元101室&quot; border=&quot;{{ false }}&quot; /&gt;
  &lt;van-cell title=&quot;业主&quot; value=&quot;内容&quot; border=&quot;{{ false }}&quot; /&gt;
&lt;/van-cell-group&gt;
        </code></pre>

        <h3>5.3.3 SwipeCell 滑动单元格</h3>

        <ol>
            <li>同样的先在 <code>app.json</code> 中全局注册组件：</li>
        </ol>

        <pre><code>
{
  &quot;usingComponents&quot;: {
    &quot;van-swipe-cell&quot;: &quot;@vant/weapp/swipe-cell/index&quot;
  },
}
        </code></pre>

        <ol>
            <li>然后将需要侧向滑动的盒子用 <code>van-swipe-cell</code> 组件包裹起来即可：</li>
        </ol>

        <pre><code>
&lt;van-swipe-cell right-width=&quot;{{ 65 }}&quot;&gt;
  &lt;van-cell-group&gt;
    &lt;van-cell size=&quot;large&quot; title=&quot;北京富力家园&quot;&gt;
      &lt;text class=&quot;tags fail&quot;&gt;审核失败&lt;/text&gt;
    &lt;/van-cell&gt;
    &lt;van-cell title=&quot;房间号&quot; value=&quot;1号楼1单元101室&quot; border=&quot;{{ false }}&quot; /&gt;
    &lt;van-cell title=&quot;业主&quot; value=&quot;内容&quot; border=&quot;{{ false }}&quot; /&gt;
  &lt;/van-cell-group&gt;
<!-- -  &lt;!-- 右侧滑动显示的按钮 --&gt; -->
<!-- +  &lt;view slot=&quot;right&quot;&gt;删除&lt;/view&gt; -->
&lt;/van-swipe-cell&gt;
        </code></pre>

        <h3>扩展-样式覆盖</h3>

        <blockquote>
            <p>Vant 组件中的组件提供了非常整齐美观的样式，但是开发中在所难免需要对原有样式进行个修改</p>
        </blockquote>

        <ul>
            <li>简单粗暴，通过调试工具查找要修改样式的盒子，找到已定义的类名，然后强制覆盖原有的样式</li>
        </ul>

        <pre><code>
.van-swipe-cell__right {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 65px !important;
  margin-left: -20px;
  text-align: center;
  color: #fff;
  background-color: #eb5757;
}
        </code></pre>

        <p>::: tip 提示:
            在进行样式覆盖时优先不够的情况下使用 !important
            :::</p>

        <ul>
            <li>使用样式变量</li>
        </ul>

        <blockquote>
            <p>新版本的 css 支持定义变量，其语法样式为: <code>--变量名: 值</code>，定义的变量通过 <code>var</code> 关键字来使用：</p>
        </blockquote>

        <ol>
            <li><strong>局部变量</strong></li>
        </ol>

        <p>举例说明：</p>

        <pre><code>
.box {
  --my-cusotm-color: pink;
  backgound-color: var(--my-cusotm-color);
}
        </code></pre>

        <p>上述代码中定义的变量只能用在 <code>.box</code> 盒子及后代元素上</p>

        <ol>
            <li><strong>全局变量</strong></li>
        </ol>

        <p>如果希望整个页面都能使用这个变量，可以这样定义：</p>

        <pre><code>
page {
    --my-cusotm-color: pink;
}
    
.box {
    backgound-color: var(--my-cusotm-color);
}
.navs {
    backgound-color: var(--my-cusotm-color);
}
        </code></pre>
            
            
        

        <ol>
            <li>了解了 css 变量的基本用法后，咱们修改 vant 中 css 变量覆盖原来样式：</li>
        </ol>

        <p>说明❓：通过调式面板，查看组件元素中用到的css变量进行覆盖</p>

        <p><img alt="image-20221202184958647" src="./images/weixin/image-20221202184958647.png" /></p>

        <pre><code>
page {
  --cell-large-title-font-size: 30rpx;
  --cell-text-color: #c3c3c5;
  --cell-value-color: #686868;
}
</code></pre>

        <h1>分包加载</h1>

        <blockquote>
            <p>分包加载有点类似 Vue 中的按需加载的功能，将小程序拆分成若干个部分叫做分包</p>
        </blockquote>

        <ol>
            <li>在分包的基础上能够实现按需加载当前所需部分小程序代码，在一定程序能够提升小程序的加载速度</li>
            <li>同时也能解决小程序代码包大小不能超过 2M 的限制</li>
        </ol>

        <h2>6.1 使用分包</h2>

        <blockquote>
            <p>分包从形式上来看就是将某些功能相关的页面及其依赖的资源放到独立的文件夹中，然后在 app.json 文件通过 <code>subPackages</code> 配置要加载的分包：</p>
        </blockquote>

        <p><code>app.json</code></p>

        <pre><code>
{
  &quot;pages&quot;:[...],
  // 省略部分代码...
+  &quot;subPackages&quot;: [
    {
+      &quot;root&quot;: &quot;分包的根路径&quot;,
+      &quot;name&quot;: &quot;分包名称&quot;,
+      &quot;pages&quot;: [
        // 分页页面的路径
+      ]
    }
  ]
}
</code></pre>

        <p><code>subPackages</code> 的值是数组类型，可以指定多个分包，每个分包含3部分信息，分别为：</p>

        <ul>
            <li><code>root</code> 分包对应的代码根目录，即分包的代码放在哪个文件夹中</li>
            <li><code>name</code> 分包的名称，可以省略</li>
            <li><code>pages</code> 分包中所包含的页面路径</li>
        </ul>

        <p>下面咱们来定义一个分包，要求分包的代码位于 <code>goods_pkg</code> 目录中，分包中包含两个页面：</p>

        <pre><code>
{
  &quot;subPackages&quot;: [
    {
      &quot;root&quot;: &quot;good_pkg&quot;,
      &quot;pages&quot;: [
        &quot;pages/list/index&quot;,
        &quot;pages/detail/index&quot;
      ]
    }
  ]
}
</code></pre>

        <p>上述代码中定义了一个分包的目录名为 <code>good_pkg</code> （这个名称可以任意起），这个分包下面包含了两个页面，分别是 <code>pages/list/index</code> 和
            <code>pages/detail/index</code>。</p>

        <p>tip 提示:
            如果配置分包的根目录及页面路径不存在，小程序将会自动创建。</p>

            <img src="./images/weixin/image-20221205094957069.png" style="zoom: 50%;" alt="">

        <p>总结：</p>

        <ol>
            <li>分包中的页面只有被访问到时小程序才会去下载相应的代码包</li>
            <li>小程序分包对应的是主包，主包就是除了分包以外的代码，<code>tabBar</code> 的页面只能放在主包当中</li>
            <li>
                <p>使用分包也不是对代码体积完全没有限制：</p>
            </li>
            <li>
                <p>整个小程序所有分包大小不超过 20M</p>
            </li>
            <li>单个分包/主包大小不能超过 2M</li>
        </ol>

        <h2>6.2 分包预下载</h2>

        <blockquote>
            <p>分包加载在打开小程序启动的时候<strong>只下载主包代码</strong>，分包并不会下载，因此能够提升小程序启动时的打开速度，分包的代码只有在访问到分包的页面时才去下载，这样用户就需要有一定时间的等待（一般不太影响），通过分包预加载技术可以实现提前去下载分包的代码，这样分包页面的访问速度也会得到提升。
            </p>
        </blockquote>

        <p>小程序通过 <code>preloadRule</code> 配置需要预加载的分包，在 <code>app.json</code> 中进行配置：</p>

        <ul>
            <li>指定某个页面路径做为 <code>key</code>，含义是当<strong>访问这个页面时会去预下载一个分包</strong></li>
            <li><code>network</code> 预下载分包的网络条件，可选值为 <code>all</code>、<code>wifi</code>，默认为 <code>wifi</code></li>
            <li><code>packages</code> 指定要预下载的分包名或根路径</li>
        </ul>

        <p><code>app.json</code></p>

        <pre><code>
{
  &quot;preloadRule&quot;: {
    &quot;pages/index/index&quot;: {
      &quot;network&quot;: &quot;wifi&quot;,
      &quot;packages&quot;: [&quot;good_pkg&quot;]
    }
  },
}
        </code></pre>

        <p>上述的代码代表的含义是当用户访问到 <code>pages/index/index</code> 时，在 <code>wifi</code> 网络前提下预先下载 <code>good_pkg</code> 分包的代码。
        </p>

        <h1>框架接口</h1>

        <p>框架接口指的是小程序提供的一些全局函数，如之前学习到的 <code>App</code>、<code>Page</code>、<code>Component</code> 函数，本节再来学习另外几个有用的函数。</p>

        <h2>7.1 getApp</h2>

        <blockquote>
            <p><code>getApp</code> 是一个全局的函数，调用该函数可以获取小程序应用实例，通过小程序应用实例可实现数据或方法的共享。</p>
        </blockquote>

        <pre><code>
// app.js
App({
  // 读取本地存储的token数据
  token: wx.getStorageSync(&#39;token&#39;),
  http(params) {
    // 举例封装网络请求
    wx.request({
      ...params,
      header: {},
    })
  }
})
        </code></pre>

        <p>在任意页面和组件中调用 <code>getApp</code> 就可以获取小程序的实例（即上述代码）：</p>

        <pre><code>
// pages/index/index.js
// 获取小程序实例
const app = getApp()

Page({
  onLoad() {
    // 能够读取到全局实全名定义的 token 数据
    console.log(app.token)

    // 调用全局实例中定义的方法
    app.http({
      url: '',
      method: 'GET'
    })
  },
})
        </code></pre>

        <h2>7.2 getCurrentPages</h2>

        <blockquote>
            <p><code>getCurrentPages</code> 获取当前页面栈，页面栈中包含的是页面的实例，数组中第一个元素为首页，最后一个元素为当前页面。</p>
        </blockquote>

        <p>warning 注意:
            不要在 App.onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。</p>

        <pre><code>
// /pages/index/index.js
Page({
  onLoad() {
    // 获取页面历史栈
    const pageStack = getCurrentPages()
    // 获取当前页面的实例
    const currPage = pageStack[pageStack.length - 1]
  }
})
        </code></pre>

        <p>获取到页面栈后根据数组的索引值可以获取到页面实例，通过页面实例可以获取页面中的路由信息。</p>

        <h2>扩展-behavior</h2>

        <blockquote>
            <p><code>behaviors</code>字段可以为页面或组件混入可复用的数据和方法</p>
        </blockquote>

        <ol>
            <li>
                <p>1.通过<code>Behavior</code>函数定义混入的数据或方法</p>
                <pre><code>
const mixin = Behavior({
    data: {
      share: '我是共享数据'
    },
    methods: {
      getShare() {
        console.log('获取共享数据：', this.data.share)
      }
    }
})
  
export { mixin }
                </code></pre>
            </li>
            <li>
                <p>2.页面中通过<code>behaviors</code>属性引入使用</p>
                <pre><code>
import { mixin } from '../../utils/mixin'
Page({
  behaviors: [mixin],
})
                </code></pre>
            </li>
        </ol>







        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>

            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>















    </div>

</body>



<script>



</script>

<!-- 引入js文件 -->
<script src="./js/html.js"></script>

<!-- 浏览器读取less文件的js -->
<script src="../lib/less.js"></script>



<!-- 引入代码高亮的js文件 -->
<script src="../lib/highlight/highlight.min.js"></script>
<!-- highlight使用方式:   -->
<!-- <pre><code class="语言">需要高亮的代码</code></pre> -->
<!-- 类名不写语言默认自动识别 -->

<!-- 初始化代码高亮 -->
<script>hljs.initHighlightingOnLoad();</script>



<!-- 引入代码显示行数的js文件 -->
<script src="../lib/highlightjs-line-numbers.js-master/highlightjs-line-numbers.js"></script>

<!-- 初始化代码显示高度 -->
<script>hljs.initLineNumbersOnLoad({ singleLine: true });</script>

<!-- 自动生成目录 -->
<script src="../lib/dist/tocbot.min.js"></script>
<script type="text/javascript">
    //目录生成初始化
    tocbot.init({
        // 在何处呈现目录。
        tocSelector: '.js-toc',

        // 在何处获取标题以构建目录。
        contentSelector: '.js-toc-content',

        // 要在内容选择器元素内获取哪些标题。
        headingSelector: 'h2,h3,h4,h5',//对h2和h3元素进行生成目录

        //对于内容中相对或绝对位置的容器内的标题。
        hasInnerContainers: true,
    });
</script>



</body>

</html>